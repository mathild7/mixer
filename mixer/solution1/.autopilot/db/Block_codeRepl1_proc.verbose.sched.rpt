

================================================================
== Vivado HLS Report for 'Block_codeRepl1_proc'
================================================================
* Date:           Tue Apr 23 23:53:36 2019

* Version:        2017.2 (Build 1909853 on Thu Jun 15 18:55:24 MDT 2017)
* Project:        mixer
* Solution:       solution1
* Product family: zynq
* Target device:  xc7z100ffg900-1


================================================================
== Performance Estimates
================================================================
+ Timing (ns): 
    * Summary: 
    +--------+-------+----------+------------+
    |  Clock | Target| Estimated| Uncertainty|
    +--------+-------+----------+------------+
    |ap_clk  |  10.00|      7.29|        1.25|
    +--------+-------+----------+------------+

+ Latency (clock cycles): 
    * Summary: 
    +-----+-----+-----+-----+---------+
    |  Latency  |  Interval | Pipeline|
    | min | max | min | max |   Type  |
    +-----+-----+-----+-----+---------+
    |   22|   22|   22|   22|   none  |
    +-----+-----+-----+-----+---------+

    + Detail: 
        * Instance: 
        N/A

        * Loop: 
        N/A

============================================================
+ Verbose Summary: Synthesis Manager
============================================================
InlineROM: 1
ExposeGlobal: 0
============================================================
+ Verbose Summary: CDFG Model
============================================================
IsTopModel: 0
ResetActiveHigh: 1
IsCombinational: 2
IsDatapathOnly: 0
HasWiredReturn: 1
HasMFsm: 0
HasVarLatency: 1
IsPipeline: 0
IsRtlPipelined: 0
IsInstanceOverlapped: 0
IsDontTouch: 0
HasImplIP: 0
IsGatedGlobalClock: 0


============================================================
+ Verbose Summary: Schedule
============================================================
* Number of FSM states: 23
* Pipeline: 0
* Dataflow Pipeline: 0

* FSM state transitions: 
1 --> 
	2  / true
2 --> 
	3  / true
3 --> 
	4  / true
4 --> 
	5  / true
5 --> 
	6  / true
6 --> 
	7  / true
7 --> 
	8  / true
8 --> 
	9  / true
9 --> 
	10  / true
10 --> 
	11  / true
11 --> 
	12  / true
12 --> 
	13  / true
13 --> 
	14  / true
14 --> 
	15  / true
15 --> 
	16  / true
16 --> 
	17  / true
17 --> 
	18  / true
18 --> 
	19  / true
19 --> 
	20  / true
20 --> 
	21  / true
21 --> 
	22  / true
22 --> 
	23  / true
23 --> 
* FSM state operations: 

 <State 1>: 6.79ns
ST_1: lev0_read (18)  [1/1] 0.00ns
newFuncRoot:8  %lev0_read = call float @_ssdm_op_Read.ap_auto.float(float %lev0)

ST_1: tmp_9 (25)  [1/1] 6.79ns  loc: mixer.cpp:29
newFuncRoot:15  %tmp_9 = fcmp olt float %lev0_read, 0xBFA99999A0000000

ST_1: tmp_1 (26)  [1/1] 6.79ns  loc: mixer.cpp:29
newFuncRoot:16  %tmp_1 = fcmp ogt float %lev0_read, 0x3FA99999A0000000


 <State 2>: 6.86ns
ST_2: StgValue_27 (10)  [1/1] 0.00ns
newFuncRoot:0  call void (...)* @_ssdm_op_SpecInterface(float* %in0_V, [5 x i8]* @p_str3, i32 1, i32 1, [5 x i8]* @p_str4, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1, [1 x i8]* @p_str1, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1)

ST_2: StgValue_28 (11)  [1/1] 0.00ns
newFuncRoot:1  call void (...)* @_ssdm_op_SpecInterface(float* %in1_V, [5 x i8]* @p_str3, i32 1, i32 1, [5 x i8]* @p_str4, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1, [1 x i8]* @p_str1, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1)

ST_2: StgValue_29 (12)  [1/1] 0.00ns
newFuncRoot:2  call void (...)* @_ssdm_op_SpecInterface(float* %in2_V, [5 x i8]* @p_str3, i32 1, i32 1, [5 x i8]* @p_str4, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1, [1 x i8]* @p_str1, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1)

ST_2: StgValue_30 (13)  [1/1] 0.00ns
newFuncRoot:3  call void (...)* @_ssdm_op_SpecInterface(float* %in3_V, [5 x i8]* @p_str3, i32 1, i32 1, [5 x i8]* @p_str4, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1, [1 x i8]* @p_str1, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1)

ST_2: StgValue_31 (14)  [1/1] 0.00ns
newFuncRoot:4  call void (...)* @_ssdm_op_SpecInterface(float* %out_V, [5 x i8]* @p_str3, i32 1, i32 1, [5 x i8]* @p_str4, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1, [1 x i8]* @p_str1, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str1, [1 x i8]* @p_str1)

ST_2: lev3_read (15)  [1/1] 0.00ns
newFuncRoot:5  %lev3_read = call float @_ssdm_op_Read.ap_auto.float(float %lev3)

ST_2: lev2_read (16)  [1/1] 0.00ns
newFuncRoot:6  %lev2_read = call float @_ssdm_op_Read.ap_auto.float(float %lev2)

ST_2: lev1_read (17)  [1/1] 0.00ns
newFuncRoot:7  %lev1_read = call float @_ssdm_op_Read.ap_auto.float(float %lev1)

ST_2: lev0_to_int (19)  [1/1] 0.00ns
newFuncRoot:9  %lev0_to_int = bitcast float %lev0_read to i32

ST_2: tmp_5 (20)  [1/1] 0.00ns
newFuncRoot:10  %tmp_5 = call i8 @_ssdm_op_PartSelect.i8.i32.i32.i32(i32 %lev0_to_int, i32 23, i32 30)

ST_2: tmp (21)  [1/1] 0.00ns
newFuncRoot:11  %tmp = trunc i32 %lev0_to_int to i23

ST_2: notlhs (22)  [1/1] 2.91ns
newFuncRoot:12  %notlhs = icmp ne i8 %tmp_5, -1

ST_2: notrhs (23)  [1/1] 3.20ns
newFuncRoot:13  %notrhs = icmp eq i23 %tmp, 0

ST_2: tmp_8 (24)  [1/1] 0.00ns (grouped into LUT with out node or_cond)
newFuncRoot:14  %tmp_8 = or i1 %notrhs, %notlhs

ST_2: tmp_2 (27)  [1/1] 0.00ns  loc: mixer.cpp:29 (grouped into LUT with out node or_cond)
newFuncRoot:17  %tmp_2 = or i1 %tmp_9, %tmp_1

ST_2: or_cond (28)  [1/1] 2.07ns  loc: mixer.cpp:29 (out node of the LUT)
newFuncRoot:18  %or_cond = and i1 %tmp_8, %tmp_2

ST_2: StgValue_43 (29)  [1/1] 1.59ns  loc: mixer.cpp:29
newFuncRoot:19  br i1 %or_cond, label %0, label %._crit_edge

ST_2: tmp_3 (31)  [2/2] 0.00ns  loc: mixer.cpp:30
:0  %tmp_3 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in0_V)


 <State 3>: 6.79ns
ST_3: tmp_3 (31)  [1/2] 0.00ns  loc: mixer.cpp:30
:0  %tmp_3 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in0_V)

ST_3: StgValue_46 (32)  [1/1] 1.59ns  loc: mixer.cpp:31
:1  br label %._crit_edge

ST_3: tmp_12 (41)  [1/1] 6.79ns  loc: mixer.cpp:32
._crit_edge:7  %tmp_12 = fcmp olt float %lev1_read, 0xBFA99999A0000000

ST_3: tmp_13 (42)  [1/1] 6.79ns  loc: mixer.cpp:32
._crit_edge:8  %tmp_13 = fcmp ogt float %lev1_read, 0x3FA99999A0000000


 <State 4>: 6.86ns
ST_4: tmp_7 (34)  [1/1] 0.00ns
._crit_edge:0  %tmp_7 = phi float [ %tmp_3, %0 ], [ 0.000000e+00, %newFuncRoot ]

ST_4: lev1_to_int (35)  [1/1] 0.00ns
._crit_edge:1  %lev1_to_int = bitcast float %lev1_read to i32

ST_4: tmp_4 (36)  [1/1] 0.00ns
._crit_edge:2  %tmp_4 = call i8 @_ssdm_op_PartSelect.i8.i32.i32.i32(i32 %lev1_to_int, i32 23, i32 30)

ST_4: tmp_6 (37)  [1/1] 0.00ns
._crit_edge:3  %tmp_6 = trunc i32 %lev1_to_int to i23

ST_4: notlhs2 (38)  [1/1] 2.91ns
._crit_edge:4  %notlhs2 = icmp ne i8 %tmp_4, -1

ST_4: notrhs2 (39)  [1/1] 3.20ns
._crit_edge:5  %notrhs2 = icmp eq i23 %tmp_6, 0

ST_4: tmp_11 (40)  [1/1] 0.00ns (grouped into LUT with out node or_cond1)
._crit_edge:6  %tmp_11 = or i1 %notrhs2, %notlhs2

ST_4: tmp_21 (43)  [1/1] 0.00ns  loc: mixer.cpp:32 (grouped into LUT with out node or_cond1)
._crit_edge:9  %tmp_21 = or i1 %tmp_12, %tmp_13

ST_4: or_cond1 (44)  [1/1] 2.07ns  loc: mixer.cpp:32 (out node of the LUT)
._crit_edge:10  %or_cond1 = and i1 %tmp_11, %tmp_21

ST_4: StgValue_58 (45)  [1/1] 1.59ns  loc: mixer.cpp:32
._crit_edge:11  br i1 %or_cond1, label %1, label %._crit_edge17

ST_4: tmp_22 (47)  [2/2] 0.00ns  loc: mixer.cpp:33
:0  %tmp_22 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in1_V)


 <State 5>: 6.79ns
ST_5: tmp_22 (47)  [1/2] 0.00ns  loc: mixer.cpp:33
:0  %tmp_22 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in1_V)

ST_5: StgValue_61 (48)  [1/1] 1.59ns  loc: mixer.cpp:34
:1  br label %._crit_edge17

ST_5: tmp_26 (57)  [1/1] 6.79ns  loc: mixer.cpp:35
._crit_edge17:7  %tmp_26 = fcmp olt float %lev2_read, 0xBFA99999A0000000

ST_5: tmp_27 (58)  [1/1] 6.79ns  loc: mixer.cpp:35
._crit_edge17:8  %tmp_27 = fcmp ogt float %lev2_read, 0x3FA99999A0000000


 <State 6>: 6.86ns
ST_6: tmp_s (50)  [1/1] 0.00ns
._crit_edge17:0  %tmp_s = phi float [ %tmp_22, %1 ], [ 0.000000e+00, %._crit_edge ]

ST_6: lev2_to_int (51)  [1/1] 0.00ns
._crit_edge17:1  %lev2_to_int = bitcast float %lev2_read to i32

ST_6: tmp_23 (52)  [1/1] 0.00ns
._crit_edge17:2  %tmp_23 = call i8 @_ssdm_op_PartSelect.i8.i32.i32.i32(i32 %lev2_to_int, i32 23, i32 30)

ST_6: tmp_24 (53)  [1/1] 0.00ns
._crit_edge17:3  %tmp_24 = trunc i32 %lev2_to_int to i23

ST_6: notlhs4 (54)  [1/1] 2.91ns
._crit_edge17:4  %notlhs4 = icmp ne i8 %tmp_23, -1

ST_6: notrhs4 (55)  [1/1] 3.20ns
._crit_edge17:5  %notrhs4 = icmp eq i23 %tmp_24, 0

ST_6: tmp_25 (56)  [1/1] 0.00ns (grouped into LUT with out node or_cond2)
._crit_edge17:6  %tmp_25 = or i1 %notrhs4, %notlhs4

ST_6: tmp_28 (59)  [1/1] 0.00ns  loc: mixer.cpp:35 (grouped into LUT with out node or_cond2)
._crit_edge17:9  %tmp_28 = or i1 %tmp_26, %tmp_27

ST_6: or_cond2 (60)  [1/1] 2.07ns  loc: mixer.cpp:35 (out node of the LUT)
._crit_edge17:10  %or_cond2 = and i1 %tmp_25, %tmp_28

ST_6: StgValue_73 (61)  [1/1] 1.59ns  loc: mixer.cpp:35
._crit_edge17:11  br i1 %or_cond2, label %2, label %._crit_edge18

ST_6: tmp_29 (63)  [2/2] 0.00ns  loc: mixer.cpp:36
:0  %tmp_29 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in2_V)


 <State 7>: 6.79ns
ST_7: tmp_29 (63)  [1/2] 0.00ns  loc: mixer.cpp:36
:0  %tmp_29 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in2_V)

ST_7: StgValue_76 (64)  [1/1] 1.59ns  loc: mixer.cpp:37
:1  br label %._crit_edge18

ST_7: tmp_33 (73)  [1/1] 6.79ns  loc: mixer.cpp:38
._crit_edge18:7  %tmp_33 = fcmp olt float %lev3_read, 0xBFA99999A0000000

ST_7: tmp_34 (74)  [1/1] 6.79ns  loc: mixer.cpp:38
._crit_edge18:8  %tmp_34 = fcmp ogt float %lev3_read, 0x3FA99999A0000000


 <State 8>: 6.86ns
ST_8: tmp_10 (66)  [1/1] 0.00ns
._crit_edge18:0  %tmp_10 = phi float [ %tmp_29, %2 ], [ 0.000000e+00, %._crit_edge17 ]

ST_8: lev3_to_int (67)  [1/1] 0.00ns
._crit_edge18:1  %lev3_to_int = bitcast float %lev3_read to i32

ST_8: tmp_30 (68)  [1/1] 0.00ns
._crit_edge18:2  %tmp_30 = call i8 @_ssdm_op_PartSelect.i8.i32.i32.i32(i32 %lev3_to_int, i32 23, i32 30)

ST_8: tmp_31 (69)  [1/1] 0.00ns
._crit_edge18:3  %tmp_31 = trunc i32 %lev3_to_int to i23

ST_8: notlhs6 (70)  [1/1] 2.91ns
._crit_edge18:4  %notlhs6 = icmp ne i8 %tmp_30, -1

ST_8: notrhs6 (71)  [1/1] 3.20ns
._crit_edge18:5  %notrhs6 = icmp eq i23 %tmp_31, 0

ST_8: tmp_32 (72)  [1/1] 0.00ns (grouped into LUT with out node or_cond3)
._crit_edge18:6  %tmp_32 = or i1 %notrhs6, %notlhs6

ST_8: tmp_35 (75)  [1/1] 0.00ns  loc: mixer.cpp:38 (grouped into LUT with out node or_cond3)
._crit_edge18:9  %tmp_35 = or i1 %tmp_33, %tmp_34

ST_8: or_cond3 (76)  [1/1] 2.07ns  loc: mixer.cpp:38 (out node of the LUT)
._crit_edge18:10  %or_cond3 = and i1 %tmp_32, %tmp_35

ST_8: StgValue_88 (77)  [1/1] 1.59ns  loc: mixer.cpp:38
._crit_edge18:11  br i1 %or_cond3, label %3, label %._crit_edge19

ST_8: tmp_36 (79)  [2/2] 0.00ns  loc: mixer.cpp:39
:0  %tmp_36 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in3_V)


 <State 9>: 7.29ns
ST_9: tmp_36 (79)  [1/2] 0.00ns  loc: mixer.cpp:39
:0  %tmp_36 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %in3_V)

ST_9: StgValue_91 (80)  [1/1] 1.59ns  loc: mixer.cpp:40
:1  br label %._crit_edge19

ST_9: tmp_14 (82)  [1/1] 0.00ns
._crit_edge19:0  %tmp_14 = phi float [ %tmp_36, %3 ], [ 0.000000e+00, %._crit_edge18 ]

ST_9: tmp_15 (83)  [4/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:1  %tmp_15 = fmul float %tmp_7, %lev0_read

ST_9: tmp_16 (84)  [4/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:2  %tmp_16 = fmul float %tmp_s, %lev1_read

ST_9: tmp_18 (86)  [4/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:4  %tmp_18 = fmul float %tmp_10, %lev2_read

ST_9: tmp_19 (87)  [4/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:5  %tmp_19 = fmul float %tmp_14, %lev3_read


 <State 10>: 5.70ns
ST_10: tmp_15 (83)  [3/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:1  %tmp_15 = fmul float %tmp_7, %lev0_read

ST_10: tmp_16 (84)  [3/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:2  %tmp_16 = fmul float %tmp_s, %lev1_read

ST_10: tmp_18 (86)  [3/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:4  %tmp_18 = fmul float %tmp_10, %lev2_read

ST_10: tmp_19 (87)  [3/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:5  %tmp_19 = fmul float %tmp_14, %lev3_read


 <State 11>: 5.70ns
ST_11: tmp_15 (83)  [2/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:1  %tmp_15 = fmul float %tmp_7, %lev0_read

ST_11: tmp_16 (84)  [2/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:2  %tmp_16 = fmul float %tmp_s, %lev1_read

ST_11: tmp_18 (86)  [2/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:4  %tmp_18 = fmul float %tmp_10, %lev2_read

ST_11: tmp_19 (87)  [2/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:5  %tmp_19 = fmul float %tmp_14, %lev3_read


 <State 12>: 5.70ns
ST_12: tmp_15 (83)  [1/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:1  %tmp_15 = fmul float %tmp_7, %lev0_read

ST_12: tmp_16 (84)  [1/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:2  %tmp_16 = fmul float %tmp_s, %lev1_read

ST_12: tmp_18 (86)  [1/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:4  %tmp_18 = fmul float %tmp_10, %lev2_read

ST_12: tmp_19 (87)  [1/4] 5.70ns  loc: mixer.cpp:42
._crit_edge19:5  %tmp_19 = fmul float %tmp_14, %lev3_read


 <State 13>: 7.26ns
ST_13: tmp_17 (85)  [5/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:3  %tmp_17 = fadd float %tmp_15, %tmp_16

ST_13: tmp_20 (88)  [5/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:6  %tmp_20 = fadd float %tmp_18, %tmp_19


 <State 14>: 7.26ns
ST_14: tmp_17 (85)  [4/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:3  %tmp_17 = fadd float %tmp_15, %tmp_16

ST_14: tmp_20 (88)  [4/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:6  %tmp_20 = fadd float %tmp_18, %tmp_19


 <State 15>: 7.26ns
ST_15: tmp_17 (85)  [3/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:3  %tmp_17 = fadd float %tmp_15, %tmp_16

ST_15: tmp_20 (88)  [3/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:6  %tmp_20 = fadd float %tmp_18, %tmp_19


 <State 16>: 7.26ns
ST_16: tmp_17 (85)  [2/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:3  %tmp_17 = fadd float %tmp_15, %tmp_16

ST_16: tmp_20 (88)  [2/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:6  %tmp_20 = fadd float %tmp_18, %tmp_19


 <State 17>: 7.26ns
ST_17: tmp_17 (85)  [1/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:3  %tmp_17 = fadd float %tmp_15, %tmp_16

ST_17: tmp_20 (88)  [1/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:6  %tmp_20 = fadd float %tmp_18, %tmp_19


 <State 18>: 7.26ns
ST_18: tmp_37 (89)  [5/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:7  %tmp_37 = fadd float %tmp_17, %tmp_20


 <State 19>: 7.26ns
ST_19: tmp_37 (89)  [4/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:7  %tmp_37 = fadd float %tmp_17, %tmp_20


 <State 20>: 7.26ns
ST_20: tmp_37 (89)  [3/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:7  %tmp_37 = fadd float %tmp_17, %tmp_20


 <State 21>: 7.26ns
ST_21: tmp_37 (89)  [2/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:7  %tmp_37 = fadd float %tmp_17, %tmp_20


 <State 22>: 7.26ns
ST_22: tmp_37 (89)  [1/5] 7.26ns  loc: mixer.cpp:42
._crit_edge19:7  %tmp_37 = fadd float %tmp_17, %tmp_20

ST_22: StgValue_124 (90)  [2/2] 0.00ns  loc: mixer.cpp:42
._crit_edge19:8  call void @_ssdm_op_Write.axis.volatile.floatP(float* %out_V, float %tmp_37)


 <State 23>: 0.00ns
ST_23: StgValue_125 (90)  [1/2] 0.00ns  loc: mixer.cpp:42
._crit_edge19:8  call void @_ssdm_op_Write.axis.volatile.floatP(float* %out_V, float %tmp_37)

ST_23: StgValue_126 (91)  [1/1] 0.00ns
._crit_edge19:9  ret void



============================================================
+ Verbose Summary: Timing violations
============================================================
Target clock period: 10ns, clock uncertainty: 1.25ns.

 <State 1>: 6.79ns
The critical path consists of the following:
	wire read on port 'lev0' [18]  (0 ns)
	'fcmp' operation ('tmp_1', mixer.cpp:29) [26]  (6.79 ns)

 <State 2>: 6.86ns
The critical path consists of the following:
	'icmp' operation ('notrhs') [23]  (3.2 ns)
	'or' operation ('tmp_8') [24]  (0 ns)
	'and' operation ('or_cond', mixer.cpp:29) [28]  (2.07 ns)
	multiplexor before 'phi' operation ('tmp') with incoming values : ('tmp', mixer.cpp:30) [34]  (1.59 ns)

 <State 3>: 6.79ns
The critical path consists of the following:
	'fcmp' operation ('tmp_12', mixer.cpp:32) [41]  (6.79 ns)

 <State 4>: 6.86ns
The critical path consists of the following:
	'icmp' operation ('notrhs2') [39]  (3.2 ns)
	'or' operation ('tmp_11') [40]  (0 ns)
	'and' operation ('or_cond1', mixer.cpp:32) [44]  (2.07 ns)
	multiplexor before 'phi' operation ('tmp') with incoming values : ('tmp', mixer.cpp:33) [50]  (1.59 ns)

 <State 5>: 6.79ns
The critical path consists of the following:
	'fcmp' operation ('tmp_26', mixer.cpp:35) [57]  (6.79 ns)

 <State 6>: 6.86ns
The critical path consists of the following:
	'icmp' operation ('notrhs4') [55]  (3.2 ns)
	'or' operation ('tmp_25') [56]  (0 ns)
	'and' operation ('or_cond2', mixer.cpp:35) [60]  (2.07 ns)
	multiplexor before 'phi' operation ('tmp') with incoming values : ('tmp', mixer.cpp:36) [66]  (1.59 ns)

 <State 7>: 6.79ns
The critical path consists of the following:
	'fcmp' operation ('tmp_33', mixer.cpp:38) [73]  (6.79 ns)

 <State 8>: 6.86ns
The critical path consists of the following:
	'icmp' operation ('notrhs6') [71]  (3.2 ns)
	'or' operation ('tmp_32') [72]  (0 ns)
	'and' operation ('or_cond3', mixer.cpp:38) [76]  (2.07 ns)
	multiplexor before 'phi' operation ('tmp') with incoming values : ('tmp', mixer.cpp:39) [82]  (1.59 ns)

 <State 9>: 7.29ns
The critical path consists of the following:
	axis read on port 'in3_V' (mixer.cpp:39) [79]  (0 ns)
	multiplexor before 'phi' operation ('tmp') with incoming values : ('tmp', mixer.cpp:39) [82]  (1.59 ns)
	'phi' operation ('tmp') with incoming values : ('tmp', mixer.cpp:39) [82]  (0 ns)
	'fmul' operation ('tmp_19', mixer.cpp:42) [87]  (5.7 ns)

 <State 10>: 5.7ns
The critical path consists of the following:
	'fmul' operation ('tmp_15', mixer.cpp:42) [83]  (5.7 ns)

 <State 11>: 5.7ns
The critical path consists of the following:
	'fmul' operation ('tmp_15', mixer.cpp:42) [83]  (5.7 ns)

 <State 12>: 5.7ns
The critical path consists of the following:
	'fmul' operation ('tmp_15', mixer.cpp:42) [83]  (5.7 ns)

 <State 13>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp_17', mixer.cpp:42) [85]  (7.26 ns)

 <State 14>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp_17', mixer.cpp:42) [85]  (7.26 ns)

 <State 15>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp_17', mixer.cpp:42) [85]  (7.26 ns)

 <State 16>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp_17', mixer.cpp:42) [85]  (7.26 ns)

 <State 17>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp_17', mixer.cpp:42) [85]  (7.26 ns)

 <State 18>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp', mixer.cpp:42) [89]  (7.26 ns)

 <State 19>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp', mixer.cpp:42) [89]  (7.26 ns)

 <State 20>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp', mixer.cpp:42) [89]  (7.26 ns)

 <State 21>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp', mixer.cpp:42) [89]  (7.26 ns)

 <State 22>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('tmp', mixer.cpp:42) [89]  (7.26 ns)

 <State 23>: 0ns
The critical path consists of the following:


============================================================
+ Verbose Summary: Binding
============================================================
N/A
* FSMD analyzer results:
  - Output states:
 - Input state : 
  - Chain level:
	State 1
	State 2
	State 3
	State 4
	State 5
	State 6
	State 7
	State 8
	State 9
	State 10
	State 11
	State 12
	State 13
	State 14
	State 15
	State 16
	State 17
	State 18
	State 19
	State 20
	State 21
	State 22
	State 23


============================================================
+ Verbose Summary: Datapath Resource usage 
============================================================
N/A
